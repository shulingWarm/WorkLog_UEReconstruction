# 目标
- 通过三维重建控制台，选择图片然后后端调用VGGT之后再调用3DGS，最后将3DGS的结果回传到UE。

# 工作过程
- [DONE] 在服务器上部署VGGT。
- [DONE] 在服务器上部署OpenSplat。
- [DONE] 部署VGGT配套的BA模型。
- [DONE] 实验发现VGGT在重建大场景时对显存要求过高，无法广泛使用。
- [DONE] 部署VGGT-Long，一个支持大场景重建的项目。
	- [DONE] 下载VGGT-Long的前置准备模型。
- [DONE] 测试VGGT-Long的场景发现对于弱纹理场景支持较差，并且具有序列化要求。
- [DONE] 为了方便后续的重建效果比较，在服务器上安装colmap并实现从C++代码启动重建。
- [DONE] 测试vggt-low-vram，尝试能否在低显存下良好工作。
	- vggt-low-vram可以在显存占用较低的情况下良好工作。
- [DONE] 实现从代码调用vggt-low-vram，用于后续和UE的通信框架集成。
- [DONE] 将vggt-low-vram和OpenSplat集成为一个完整的pipeline，通过临时文件交互即可。
- [DONE] 由于UE端维护的数据结构越来越复杂，现在改用智能指针来维护数据。
- [DONE] 实现从UE向server发起重建请求，包括发送多个图片文件的过程。
	- [DONE] 定义用于重建任务的消息包。
	- [DONE] 添加完成重建时的后处理回调。
	- [DONE] 在server端实现重建消息包的接收逻辑。
	- [DONE] 实现图片序列连续发送的逻辑，用于一次调用直接发送多个图片。
	- [DONE] 每发送完一个图片都向server端发送一个确认消息。
	- [DONE] server收到一个图片的确认消息后，将图片保存在workspace用于后续重建。
	- [DONE] server收到所有图片后开始执行重建。
- [DONE] 实现可以从socket_server调用的pipeline，先调用vggt再调用3DGS。
- [DONE] 实现从socket_server将重建结果回传给UE。
- [DONE] UE从socket的回传结果中解析3DGS数据。
- [DONE] 要SocketServer里面添加队列用于表示待处理的需要添加的Gaussian结果。
- [DONE] 解耦之前从文件中加载3DGS的逻辑。
- [DONE] 在UE的蓝图里面通过重建按钮调用服务器里面的重建逻辑。
- [DONE] 解决server在import时无法import gaussian splatting的问题。
	- 将GaussianSplatting库里面的utils文件夹改名后解决。
- [DONE] 解决UE无法正常读取JPG格式图片导致无法发送图片的问题。
	- UE端直接读取JPEG图片，然后将未解压的JPEG图片发送到python端。
- [DONE] 解决UE端读取到的JPEG图片数据为空的问题。
	- 之前读取图片的时候传入的是文件名，传对绝对路径就可以了。
- [DONE] server上将计算结果回传给UE后，UE可以正常保存下来，且保存下来的数据正常。
- [DONE] 解决UE上没有正常将3DGS显示在场景中的问题。
	- 事件处理那里没有调用加载3DGS的函数导致的。
- [DOING] 为了后续视频展示效果，解决3DGS查看工具的使用BUG。
	- [DONE] 解决旋转或者缩放工具打开关闭后不能第二次打开。
	- [DOING] 解决旋转工具每次打开后会跟随目标物体一起放大旋转。