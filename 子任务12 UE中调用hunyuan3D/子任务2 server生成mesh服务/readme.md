# 目标
- 在Server上实现收到图片后异步生成Mesh。
- 当异步生成Mesh完成后返回给请求者。

# 工作过程
- [DONE] 实现由已经加载好的图片生成Mesh，而不是pipeline默认那个传入图片路径的形式。
- [DONE] 定义由Server调用生成Mesh的消息，需要实现为异步生成的形式。
- [DONE] 在C++端实现请求server生成Mesh的消息。
- [DONE] 测试从发起请求到开始生成Mesh的pipeline能否正常执行。
- [DONE] 确认mesh里面节点的uv是否存在。
	- 结果: 不存在，需要手动创建uv。
- [DOING] 实现mesh生成完成后的回传过程。
	- [DONE] 创建发送mesh的数据头。
	- [DONE] C++接收数据头。
	- [DONE] C++定义抽象的Mesh接口，用于做mesh动态读写。
	- [DONE] Python实现Mesh的动态接口，用于做mesh的动态读写。
	- [DONE] 实现指定的vertex序列的请求消息。
	- [DONE] C++收到回传消息后，请求下一行的消息。
	- [DONE] 服务端检查是否已经发送了所有的节点，如果已经发送了所有节点，向客户端发送通知。
	- [DONE] 解决客户端新写代码的编译错误。
	- [DONE] 服务端从文件中加载一个mesh用于测试向客户端发送mesh。
	- [DONE] 完成节点传输后，将mesh的每个face也分包发送给C++端。
		- [DONE] 实现face传输的包控制逻辑。
		- [DONE] 测试face的传输效果。
	- [DONE] C++端的MeshSolver子类实现添加节点和face的功能(还没有实现添加UV)。
	- [DONE] 部署hunyuan3D里面的贴图生成过程, 这样python端就可以存在UV了。
		- [DONE] 实现hunyuan3D的部署pipeline。
		- [DONE] 解决因differs版本问题导致的paint模型加载错误。
		- [DONE] 验证paint模型生成的贴图的效果。
		- 结果: 生成一次模型贴图需要超过20分钟，这是一个过于长的时间，因此需要寻找更快速的方案。
	- [DONE] 子任务 部署hunyuan3D 2.1，为了寻找一个时间更快的贴图生成模型。
	- [DONE] 封装hunyuan3D 2.1生成贴图的pipeline，将它与Hunyuan3D 2的mesh生成过程融合。
		- [DONE] 实现了适用于服务端的输入已经加载好的数据的pipeline。
		- [DONE] 测试发现用已经加载好的数据执行3D资源生成时速度过慢。
		- [DONE] 查检用加载好的图片生成3D资源速度慢的原因。
			- 原因是python里面无法做到真正的异步运算，它底层实现的是伪多线程。
		- [DONE] 将python里面hunyuan3D的推理过程改成同步调用，推理时不再处理消息。后续考虑改成多进程实现。
		- [DONE] 解决加载好的mesh没有经过降采样导致的贴图生成速度过慢的问题。
		- [DONE] 解决mesh回传时造成的C++端崩溃问题。
	- [DOING] 回传mesh的uv。
		- [DOING] 实现通用的传输长数组的消息。
		- [TO-DO] 基于通用的长数组传输消息传输UV内容。