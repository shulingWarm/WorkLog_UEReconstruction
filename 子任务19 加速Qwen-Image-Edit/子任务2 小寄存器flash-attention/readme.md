# 目标
- 重新使用寄存器使用较小的flash-attention.

# 工作过程
- [DONE] 准备用于测试flash-attention的输入数据。
- [DONE] 准备执行flash-attention计算过程的寄存器。
- [DONE] 准备把query复制到共享内存过程中，先把全局内存的query复制到寄存器中。
- [DONE] 开辟了用于准备KV数据的共享内存以及双重缓冲机制。
- [DONE] 将query的加载量改成warp_num\*mma_n_size\*
	- 改成mma_n_size是为了减少共享内存的使用量。
	- 根据warp_num来加载是为了让每个warp可以并行执行mma计算。
	- 删除双缓冲机制，靠SM自行调度来隐藏延迟。
- [DONE] 阶段性验证query的寄存器加载效果。
	- [DONE] 验证query的寄存器发现全是零。
	- [DONE] 寻找query寄存器为什么导出内容全是零。
		- 后续的将寄存器复制到共享内存导致了if判断失效。
	- [DONE] 重新验证query的寄存器是否正常。
	- 核函数里面的query排布符合预期。
- [DONE] 解决打开query复制共享内存时if判断block id失效的问题。
	- [DONE] 验证发现寄存器和共享内存单独赋值时都可以正常工作。
	- [DONE] 给共享内存赋值定值时，并没有对所有共享内存生效。
	- [DOING] 研究给共享内存写常量为什么不生效。
		- [DONE] 研究发现共享内存的写入位置仅限于0~8，但共享内存的长度有4096.
		- [DONE] 研究共享内存写入位置的id异常问题。
			- 原因是与运算优先级低于加减运算。
		- [DONE] 进一步缩减共享内存写入相关的代码块，用于暴露本质问题。
		- 最终发现的原因是X方向的线程块个数设置得太多了，具体来说是每个线程块使用的MMA_N_SIZE错误。
- [DOING] 验证query加载到共享内存的数据排布是否符合预期。
	- [DONE] 初步验证发现共享内存仍然和原始的query排布一样，并不是按照K方向重排过的。
	- [TO-DO] 解决共享内存内容和原始query一样的问题。
- [TO-DO] 计算qkt之前将数据从共享内存加载到寄存器中用于准备mma计算。
	- [DONE] 根据m16n8k16的计算布局要求，将query从共享内存加载到寄存器。
- [TO-DO] 修改一次加载K一次加载V的双缓冲机制。
	- 由于flash-attention需要完整算完一整列的Q\*K^T，所以需要分别完整地加载K和V。
	- [DONE] 修改依次加载KV的数据结构。
	- [TO-DO] 实现在每个计算qkt结束后加载V数据。
