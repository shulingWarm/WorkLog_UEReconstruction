# 目标
- 重新使用寄存器使用较小的flash-attention.

# 工作过程
- [DONE] 准备用于测试flash-attention的输入数据。
- [DONE] 准备执行flash-attention计算过程的寄存器。
- [DONE] 准备把query复制到共享内存过程中，先把全局内存的query复制到寄存器中。
- [DONE] 开辟了用于准备KV数据的共享内存以及双重缓冲机制。
- [DONE] 将query的加载量改成warp_num\*mma_n_size\*
	- 改成mma_n_size是为了减少共享内存的使用量。
	- 根据warp_num来加载是为了让每个warp可以并行执行mma计算。
	- 删除双缓冲机制，靠SM自行调度来隐藏延迟。
- [DONE] 阶段性验证query的寄存器加载效果。
	- [DONE] 验证query的寄存器发现全是零。
	- [DONE] 寻找query寄存器为什么导出内容全是零。
		- 后续的将寄存器复制到共享内存导致了if判断失效。
	- [DONE] 重新验证query的寄存器是否正常。
	- 核函数里面的query排布符合预期。
- [DONE] 解决打开query复制共享内存时if判断block id失效的问题。
	- [DONE] 验证发现寄存器和共享内存单独赋值时都可以正常工作。
	- [DONE] 给共享内存赋值定值时，并没有对所有共享内存生效。
	- [DOING] 研究给共享内存写常量为什么不生效。
		- [DONE] 研究发现共享内存的写入位置仅限于0~8，但共享内存的长度有4096.
		- [DONE] 研究共享内存写入位置的id异常问题。
			- 原因是与运算优先级低于加减运算。
		- [DONE] 进一步缩减共享内存写入相关的代码块，用于暴露本质问题。
		- 最终发现的原因是X方向的线程块个数设置得太多了，具体来说是每个线程块使用的MMA_N_SIZE错误。
- [DONE] 验证query加载到共享内存的数据排布是否符合预期。
	- [DONE] 初步验证发现共享内存仍然和原始的query排布一样，并不是按照K方向重排过的。
	- [DONE] 解决共享内存内容和原始query一样的问题。
	- 最终确认共享内存里面的数据排布符合预期。
- [DONE] 设计key tensor从全局内存加载到共享内存的方案。
- [DONE] 开发key tensor从全局内存加载到共享内存的方案。
- [DONE] 验证存储key tensor的共享内存内容符合预期。
	- [DONE] 验证发现key tensor的打印内容全是零。
	- [DONE] 寻找key tensor访问越界的地方。
		- [DONE] 从寄存器加载到共享内存时访问到了512位置的偏移量，可能对于共享内存的初始化有问题。
		- [DONE] 验证共享内存的KEY区间长度到底是不是预期的2048长度。
		- [DONE] 解决共享内存从寄存器复制到共享内存时，错误使用了warp分块的头指针的问题。
		- [DONE] 解决key的全局指针错误使用了bf16类型的问题。
		- [DONE] 继续debug key的共享内存分布不符合预期的问题。
	- 解决指针偏移量的bug后，key的共享内存内容符合预期。
- [DONE] 发现沿K方向16个数字为一组的重排方式仍然会有bank冲突，需要改成8个数字为一组。
	- [DONE] 确定需要用十字划分的方式将K矩阵分成4个部分来让每个warp加载。
	- [DONE] 实现按十字划分的K加载方式。
	- [DONE] 验证按十字划分的K加载方式。
		- [DONE] 第一象限的K共享内存内容验证通过。
		- [DONE] 研究其他象限K共享内存不符合预期的原因。
- [DONE] 将query改成沿K方向8个数字为一组，重新加载到共享内存里面，方便后续计算。
- [DONE] 验证query从全局内存加载到共享内存的效果，符合预期。
- [DONE] 计算qkt之前将数据从共享内存加载到寄存器中用于准备mma计算。
	- [DONE] 根据m16n8k16的计算布局要求，将key从共享内存加载到寄存器。
	- [DONE] 根据m16n8k16的计算布局要求，将query从共享内存加载到寄存器。
- [DONE] 准备用于存储mma计算的输出矩阵。
- [DONE] 完成mma计算开发。
- [DOING] 开发对QK^T结果的softmax操作。
	- [DONE] 准备增量式计算attention的数学公式。
	- [DONE] 准备Q\*K^T当前的最大值维护。
	- [DONE] 确认原版的flash-attention里面使用的也是蝴蝶寻址。
	- [DONE] 在手搓的flash-attention里面用蝴蝶寻址实现维护QK^T的最大值。
		- [DONE] 确认异或蝴蝶寻址的使用规则。
		- [DONE] 完成单个线程内的求最大值操作。
		- [DONE] 使用胡蝶寻址维护跨线程的Q\*K^T最大值。
		- [DONE] 由于M,N方向搞反，需要重新维护QK^T的最大值。
			- [DONE] 确认沿着key方向的4,8,12,...,28的线程号的交换规则。
			- [DONE] 用hard coding的交换规则实现数据交换.
		- [DONE] 维护QK^T结果的指数和。
			- [DONE] 构造QK^T的指数和变量。
			- [DONE] 实现蝴蝶寻址相加的部分。
	- [DONE] 准备attn_score×V部分的score寄存器。
- [DOING] 开发attn_score\*V的过程。
	- [DOING] 将value从全局内存加载到共享内存。
	- [TO-DO] 将value从共享内存加载到寄存器。
